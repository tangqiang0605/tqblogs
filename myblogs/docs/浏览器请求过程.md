本文主要简单介绍浏览器的请求过程，不涉及具体代码，内容也偏口语化，阅读起来还是比较容易的。如果文中存在疏漏和错误，可以通过提交[Issues](https://github.com/tangqiang0605/tqblogs/issues)向我反馈，感谢！

## 赞美浏览器
软件是安装在硬件上可以运行的一套代码，用来操作硬件。我们经常在计算机硬件上安装一个软件，叫windows。除了windows，我们一般还会再安装另一个软件，前端人员的好伙伴：浏览器。
浏览器是一个复杂的软件，谷歌家的浏览器就有四千万行代码，几乎是windows的一半。一个浏览器，也就相当于小半个操作系统（操作系统也是一种软件的类型）。
现代的浏览器是非常智能的，它实现了不同设备之间的网络通信，如果你想获得其他计算机的资源，你可以使用浏览器（当然你也可以使用其他软件，他们也可以实现网络通信。比如你打开
B站app，里面的数据也是从网络上获取的，说明它也具备网络通信的功能）。浏览器解决了很多实现问题，配合网络协议，构成了计算机网络应用层中的重要部分。浏览器是网络信息传播的终点。
本文将讲解浏览器请求的过程，这只是浏览器功能的冰山一角，但相信你了解之后，也会逐渐认识到浏览器的伟大！

## 什么是浏览器请求
网络通信，就是和网上的其他设备进行信息交换。这些设备，我们一般称为主机，因为是网络上的，又叫网络主机。网络通信其实就是网络主机之间相互交流信息。如果我们忽略中间的传输环节，只关注交流的终点和起点，也就是假设主机A和主机B在交换信息，我们忽略信息从一个主机传输到另一个主机过程中需要经过的网络、路由等传输中介，暂时只关注信息达到的终点，也就是主机A和主机B本身。

常见的主机是计算机。所以下面我们暂时把网络通信看成是计算机与计算机的通信。一个计算机可以同时和多个计算机交流，这个不足为奇。但是如果这个计算机可以同时和成千上万个计算机交流，而在这成千上万的计算机看来，他们只不过在和一个计算机交流。就像幼儿园老师，每个孩子都和老师说话，而老师要一个一个回复孩子们的反应，老师这边肯定是比较累的，老师的谈话对象有很多个，而每个孩子的谈话对象只有老师一个。所以这台特别的计算机，性能自然是比其他计算机好，我们一般把高性能的计算机，称为服务器。网络服务器就是用来同时处理数量巨大的普通计算机的网络通信。

在浏览器里，网络通信被具体化为一个个请求，计算机被抽象为一个个ip地址。一个计算机和另一台计算机


当用户使用浏览器想要进行网络通信，
浏览器请求过程分为三个阶段：发送请求前（缓存命中策略），请求中（CDN分发式网络），请求后（同源策略）。

## 什么是浏览器请求
浏览器发送请求，目的是为了获取数据，比如图片、网页、文字等内容。在用户的层面来看，一种是手动的请求，一种是自动的请求。

手动的请求：我们输入网址，手动回车，浏览器就会请求这个网址，一般返回的是一个html页面，也可以是其他信息。如果是html，浏览器就会进行解析和渲染，展示在用户面前。比如，输入www.taobao.com，就可以获得一个html文件，浏览器会自动解析并渲染成一个页面。
>小技巧，在一些网站的域名后面，加上/favicon.ico，就会获得一个图片文件。

这里要改变一个认识，就是一个链接并不是代表一个网页，而是一个代表网络资源的路径。www.taobao.com是一个html文件，www.taobao.com/favicon.ico是一个ico图片文件，他们都只是一份网络资源，只不过我们的浏览器很聪明，会对不同的文件类型进行对应的处理，然后再渲染在页面上。

自动的请求：解析html页面的过程中，可能页面包含字体文件、图片文件，浏览器就会再发送请求，获取这些文件。**请求的目的就是为了获取数据。** 在用户浏览网页时，某些浏览行为也会触发监听事件发送请求。请求是网页和用户交互的一个重要手段，网页的内容变化可以依靠自身的代码、读取本地的数据，也可以通过请求这一途径，获取非本地资源和数据进行页面展示。

完整的请求经历顺序：缓存命中决策，DNS解析、tcp连接

## 缓存
不管是读取网络资源还是读取本地资源，都是读取资源，本质上是IO操作。IO操作消耗性能，而缓存可以减少IO操作，节约计算机资源。计算机读取资源时，先从缓存读取，如果缓存有对应资源，就不需要从硬盘里读取了。

假定浏览器第一次访问了这个资源，服务端给这个资源的备注是，把它留在浏览器里，而且一天内不用再找我要了，这样，当浏览器再次需要请求这个资源时，想起服务端说过的这句话，就在自己的缓存里查找这个资源，这样就减少了网络IO，也节约了网络资源（浏览器不用发送请求给服务端，服务端也不用再回应了）。

具体的流程是：浏览器发送请求，准备获取某个资源时，会先检查本地是否存在对应的强缓存资源，如果有而且这个资源没有过期，就会直接读取这个资源，取消这个请求，自己接受一个自己生成的响应，状态码为200。如果过期了，就会发送请求向服务器询问服务器上的资源有没有更新，如果没有，那么缓存中的资源可以继续使用，浏览器就会更新缓存中该资源的更新时间。如果浏览器中没有这个资源，而不是资源过期，那浏览器则会直接请求服务器获得新资源（新资源，这里也就是缓存里没有的资源）。所以，只有当资源过期而且服务器也告诉浏览器说浏览器这边缓存的资源确实过期了，或者浏览器本来没有这个资源，浏览器才会真正获取新资源。

获得新资源后，服务器可以在请求头给这份资源留个备注，告诉浏览器是否缓存这个资源，缓存多久。浏览器就会更根据这个要求缓存这个新资源，并在这个过期时间内，只要请求这个资源，都会直接从缓存拿。这就是**强缓存**，服务器要求浏览器对资源进行缓存。

缓存的资源的过期时间不宜过大，也不宜过小。如果缓存的过期时间太短，拿到没多久就过期了，过期的缓存不会被删除（缓存什么时候删除，要看它是什么类型的缓存，不同类型的缓存有不同的回收机制）。浏览器发现过期，就会向服务器发送请求，拿着当初拿到这个资源的时间，询问服务器这边的资源从那个时间到现在的这段时间里，服务器这边的资源的内容是否有更新，如果没有，服务器会告诉浏览器这边资源没有更新，浏览器就会更新缓存里的资源的过期时间，把开始计算过期的时间改为服务器这边回应时候的时间，然后继续拿缓存里的资源。这时候，浏览器会定义服务端响应的状态码为302，也就是重定向：本来是发现过期，找服务器要，服务器告诉你可以继续使用原来的。

如果服务端发现确实过期了，在后面的时间里，服务端这边的这个资源又有了更新，这时服务端就会把新资源返回给浏览器。这就是**协商缓存**：浏览器发现强缓存的资源过期了，就向服务器询问资源是否有更新，最终都会获得资源，更新资源的过期时间。

缓存流程总结：浏览器需要请求资源，判断是否命中强缓存，是，返回资源，否，进行协商缓存，是否命中协商缓存，是，重定向缓存里的资源，否，浏览器返回新资源。

## 缓存策略
通过缓存，可以节省掉一部分的浏览器请求和资源传输消耗的资源。如何利用缓存实现性能优化的最佳实践方法就是缓存策略。

vite开发服务器的缓存策略是强缓存+哈希。当浏览器向vite开发服务器（后面暂时用vite替代vite开发服务器）请求资源时，浏览器会检查是否命中强缓存和协商缓存，如果都不命中，服务器返回资源，这里vite定义返回的资源过期时间是一年，如果一年内浏览器向vite请求这个资源，都不会再向vite服务器发送请求了，而是直接从内存里面拿。那么这里就会有一个问题，这个缓存时间太长了，虽然节省了很多http请求，但是如果这一年内vite服务器上的内容有更新，浏览器读取的还是一年前的资源。

事实上，vite服务器上的文件一旦发生改变，浏览器可以立即得到更新，这是什么原理呢？因为vite开发服务器给资源加了一个哈希后缀，这个哈希值是根据文件内容生成的，不同文件内容有不同的哈希值，只有文件内容相同，哈希值才会相同。比如浏览器向服务器请求文件，请求的文件其实是：原来的文件名+根据文件内容生成的简短字符串（也就是哈希码）+文件后缀，文件内容更新了，vite就会将其命名为：改了内容的文件名+根据新内容生成的与原来不同的哈希值+文件后缀。

举个例子，浏览器从vite开发服务器拿了一个名“hello_f213x8.doc”的文件，并缓存下去，浏览器里就有一个“hello_f213x8.doc”为期一年

## CDN


## 同源策略
源，也就是域，由协议+域名+端口组成。常见的协议有http/https、websocket、file等，域名紧跟在协议后面。不同源直接进行通信，称为跨源/跨域通信。为了方便理解，后面我们暂时把源称为网站。

**同源策略：隔离不同网站的资源。** 如果没有同源策略，不同网站之间的资源可以相互访问，一是存在安全问题，二是容易产生名称冲突。同源策略的主要内容是限制cookie的范围和限制资源在不同网站间的交流。

cookie其实也属于网站的资源，限制cookie的范围，就是在浏览器中（cookie是存放在浏览器的），网站A无法直接访问读取网站B的cookie，网站A的cookie也不会被其他网站读取。如果没有同源策略，网站A有一个叫hello的cookie，网站B这时也写入一个hello的cookie，就会盖过A原来设置的值；而且cookie常用于保存用户状态，向其他不可信网站暴露用户状态是不安全的。**简单的说就是网站A访问不到网站B的cookie。** 但是，这并不意味B是完全得不到A的cookie。B确实无法直接访问A的cookie，但是A可以主动把cookie发给B，B就知道A的cookie了。

那么如何限制资源在不同网站间的交流呢？A向B发送ajax请求时，会在请求头附带Origin信息，表示这个请求是从A发来的，B检查**可被允许的源列表**，如果有A，就接受A的请求并将处理的数据返回给A。如果A不在B的可被允许源列表里，那肯定是访问不到B的资源了，因为B不会给任何回应。A一直发，就一直得不到回应，就好像没有发过这个信息给B一样，B不用回应这些不需要回复的请求，可以节省B的资源消耗。如果B很宽松，没有设置特定的访问者，谁来访问都返回，这时A可以收到吗？也不行，A会检查B返回的请求头里的**Access-Control-Allow-Origin**有没有自己，如果没有自己，就算本来是A向B发送请求，A也不接受这则回应，认为这不是自己的，这时浏览器会报**跨域错误**。

这就好比小张喜欢一个女生，小张给这个女生写情书，在信封上写上自己的名字（Origin：小张），如果小张是女生的意中人，女生就会回复小张，如果小张不在女生的可考虑回应的人里面，女生信封都没拆就丢了，小张不管怎么发都不会收到回应，小张还会想是不是信件没送到女生手里呀。而女生如果回复小张的时候在信封上写错了名字，写成Access-Control-Allow-Origin：小李，那么小张也会放弃这封信，认为女生写给小李，没拆开信封，默默把信丢了，并在日记本记下这糟糕的事情：No ‘Access-Control-Allow-Origin’ header is present on the requested resource（跨域错误）。

注意上述流程是在A向B发送Ajax请求时发生的事情，如果不是ajax请求呢？当浏览器解析网站A的html文件生成页面，如果html包含link、script、img、iframe这四个玩意，解析到就会发送这个标签上面的链接，向链接的源请求资源，这时B一般也没有检查A在不在允许的源里，而是返回解析html过程中提到的需要从B这里拿的js文件、图片文件、css文件等。

通过这种方式请求的文件，实际上并不完整（所以说同源策略是对不同源资源交流的限制）。怎么个不完整法？可以执行js但js的上下文不能是A，可以执行css但是读不到css文件，可以显示图片但是无法读取图片的像素，iframe可以显示整个B网页但是无法获取B网页的元素。看起来好像奇奇怪怪的，总结起来就是只获取这些文件运行时的状态，而不是完整的内容。js可以跑，但是不能读取A的上下文，因为js文件是从B过来的，不确定是不是安全的，只能读B的上下文，同源策略就是要限制不同源文件间的交流。A可以执行css文件得到结果，但是不知道从B得来的css文件是什么样的，这保护了B的css文件资源，img也是同理。我们使用iframe，可以直接加载B的整个页面，如果这个时候我们在A里用iframe打开B，B是输入密码，A是读不到B的元素，也就得不到B的密码，保护了用户的安全。

总之，记住同源策略就是对资源的限制就可以了。如果是ajax请求，可能会引发跨域问题，如果是标签解析，可以得到功能不完整的文件。

## 跨域问题
如果没有同源策略（SOP），资源之间的访问也不会受到限制，而网景之所以发明这玩意，是因为这样可以很好地防范xss、csfr等攻击（后面会介绍）。同源策略，是现代浏览器最基本最核心的安全功能。同源策略就是对不同源的资源交流进行限制。有利就有弊，它保护了浏览器的安全，也产生了跨域问题。就是防着防着把自己也防了。

如果网站A和网站B都是我自己的，而且我也需要两者进行资源沟通，就会受到同源策略的阻挠。解决方法很简单，就是在响应头里加Access-Control-Expose-Headers字段。在B响应头的Access-Control-Expose-Headers中包含A，在A的响应头Access-Control-Expose-Headers里包含B即可。

但实际上这里一般不是网站A和网站B，而是主机A和主机B，上面各跑一个源。假设主机A是客户端，也就是用户的电脑打开了网站A，主机B是服务端，二者使用不同的源进行资源通信，因为同源策略，在没有任何设置的情况下，A发送的ajax请求得到了B的回应，浏览器会报跨域错误，这时设置B回应里的响应头就可以了。因为同源策略是运行在浏览器上的，所以A向B发送信息，B是不会报跨域错误的。

### jsonp
除了设置请求头解决跨域问题，还有两种解决跨域的方法，但他们并不是真正的跨域，而是把跨域的情况转变成不跨域的情况。

jsonp是一种hack技术，hacker就是黑客，但最早的时候hack是对优秀的技术的称赞，看到一个技术很厉害，就夸奖：hack！

之前说到，跨域错误是浏览器在网站A发送ajax请求到另一个网站时可能发生的错误。浏览器解析html时，通过标签script、link、iframe、img请求其他网页的资源并不会发生这种错误（本来就不是ajax请求）。所以当ajax遇到错误时，我们把ajax发送请求转为script发送请求，就可以避开这个错误了。

我们也说了，script得到的是不完整的js，它不能访问A的上下文，为了实现数据传输，需要客户端代码和服务端代码天衣无缝的配合实现：原来的时候我们通过ajax发送请求，然后处理数据。如果要使用jsonp，就把原来发送ajax请求的地方替换为dom操作，生成一个script标签，这个标签的src属性就是我们要请求的url（这里也就限制了只能使用get方法），浏览器解析html发现了这个script，就发送请求。而在服务端，接到请求后的js代码是一个函数调用，包含服务器处理好的数据作为参数，比如，服务器返回js代码，sayHello("我收到你发给我的请求了，这句话是回应的数据")，客户端接受到就会马上执行（客户端代码应该提前写好这个sayHello函数），这样就实现了数据传输。

jquery也对这个方法进行了封装。不过jsonp是以前的技术了，也只支持get请求（不安全）。get请求为什么是不安全的？因为很多网络攻击都可以轻易的利用get欺骗服务器（具体原因先挖个坑，后面补上）。首先先确定get是不安全的，所以get请求只能用来执行一些不涉及隐私和财产的操作。因此jsonp的使用范围也是有限的。

## proxy
解决跨域问题的三种方法，最早的是jsonp，现在常用的则是设置响应头或者使用代理（proxy）。跨域使用ajax会报跨域错误，一是跨域，二是使用ajax，jsonp避开了第二个条件，而proxy则是避开了第一个条件，让网站A和网站B同源。

怎么让网站A和网站B同源，明明二者就是不同源呀？很简单，套个服务器。浏览器要获取一个网页，先访问网页的服务器，从这个服务器获得网页，现在我们打开了网站A了，如果我们向发送请求给网站B，先让网站A自己的服务器代理一下，也就是，网站A先发送给自己的服务器（这是同源，没有报错），自己的服务器去网站B拿数据（没有问题），再服务器交还给A（还是同源，没有报错）。

和之前有什么区别？之前的流程是：浏览器向服务器A请求获得网页，网页在浏览器上向服务器B发送请求，服务器B返回给浏览器，所以报错。现在是：浏览器向服务器A请求获得网页，网页在浏览器上向服务器A又发送请求，服务器A请求服务器B，然后服务器A返回给浏览器，还是同源，没有问题。为了区分前后两个服务器，我们称后面这类服务器为代理服务器。

在vue2中，可以通过这种方式（webpack）配置代理服务器。当axios的baseUrl为/api时，就会自动替换为http://dev.taobao.com/api。
```js  
// vue.config.js  
module.exports = {  
  devServer: { // 配置开发服务器  
    proxy: { // 配置代理  
      "/api": { // 若请求路径以 /api 开头  
        target: "http://dev.taobao.com", 
        // 将其转发到 http://dev.taobao.com  
      },  
    },  
  },  
};
```

